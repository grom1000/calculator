"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var fs = require('fs-extra');

var webpack = require('webpack');

var EntryPlugin = require('webpack/lib/SingleEntryPlugin');

var MiniCssExtractPlugin = require('mini-css-extract-plugin');

var HtmlWebpackPlugin = require('html-webpack-plugin');

var _require = require('./utils'),
    collectFiles = _require.collectFiles,
    randomNum = _require.randomNum,
    recursiveIssuer = _require.recursiveIssuer;

var TEMP_DIR = path.resolve(process.cwd(), 'temp');
var TEMP_THEMES_DIR_NAME = 'themes';
var TEMP_THEMES_DIR = path.resolve(TEMP_DIR, TEMP_THEMES_DIR_NAME);
var DEFAULT_STYLE_NAME = 'default';
var pluginInfo = {
  name: 'ThemesGeneratorPlugin'
};
var DEFAULT_THEME_OUTPUT_DIR = 'static/theme/';
var DEFAULT_CSS_OUTPUT_NAME = '[name]-[hash].css';

var ThemesGeneratorPlugin =
/*#__PURE__*/
function () {
  function ThemesGeneratorPlugin(options) {
    _classCallCheck(this, ThemesGeneratorPlugin);

    this.options = options;
  }

  _createClass(ThemesGeneratorPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      var _this$options = this.options,
          _this$options$clearTe = _this$options.clearTemp,
          clearTemp = _this$options$clearTe === void 0 ? true : _this$options$clearTe,
          disable = _this$options.disable,
          srcDir = _this$options.srcDir,
          themesDir = _this$options.themesDir,
          outputDir = _this$options.outputDir;

      if (disable) {
        return;
      }

      if (!srcDir) {
        console.log('srcDir can not be empty');
        return;
      }

      if (!themesDir) {
        console.log('themesDir can not be empty');
        return;
      }

      if (!outputDir) {
        console.log('outputDir can not be empty');
        return;
      }

      var themeList = this.getThemeList();
      var webpackNewVer = 'hooks' in compiler;

      var onEntryOption = function onEntryOption(context) {
        if (_typeof(compiler.options.entry) !== 'object') {
          console.log('Entry must be an object if ThemesGeneratorPlugin was used!');
          return;
        }

        console.log('Themes generating started...');
        var finalThemes = {};
        var publicPath = compiler.options.output && compiler.options.output.publicPath ? compiler.options.output.publicPath : '';

        if (themeList && themeList.length > 0) {
          if (!compiler.options.optimization) {
            compiler.options.optimization = {};
          }

          if (!compiler.options.optimization.splitChunks) {
            compiler.options.optimization.splitChunks = {};
          }

          if (!compiler.options.optimization.splitChunks.cacheGroups) {
            compiler.options.optimization.splitChunks.cacheGroups = {};
          }

          themeList.forEach(function (theme) {
            var entryPlugin = new EntryPlugin(_this.context || context, theme.path, theme.key);

            if (webpackNewVer) {
              entryPlugin.apply(compiler);
            } else {
              compiler.apply(entryPlugin);
            }

            compiler.options.optimization.splitChunks.cacheGroups[theme.key] = {
              test: function test(m, c) {
                var entry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : theme.key;
                return m.constructor.name === 'CssModule' && recursiveIssuer(m) === entry;
              },
              chunks: 'all',
              enforce: true
            };
            var finalOutputDir = outputDir || DEFAULT_THEME_OUTPUT_DIR;
            finalOutputDir = finalOutputDir.endsWith('/') ? finalOutputDir : "".concat(finalOutputDir, "/");
            finalThemes[theme.key] = publicPath ? "".concat(publicPath).concat(publicPath.endsWith('/') ? '' : '/').concat(finalOutputDir).concat(theme.outputName) : "".concat(finalOutputDir).concat(theme.outputName);
          });
        }

        var definePlugin = new webpack.DefinePlugin({
          process: {
            themes: JSON.stringify(finalThemes)
          }
        });

        if (webpackNewVer) {
          definePlugin.apply(compiler);
        } else {
          compiler.apply(definePlugin);
        }

        var orgMiniCssExtractPlugin;

        if (compiler.options.plugins && compiler.options.plugins.length > 0) {
          compiler.options.plugins.forEach(function (plugin) {
            if (plugin instanceof MiniCssExtractPlugin) {
              orgMiniCssExtractPlugin = plugin;
            }
          });
        }

        var moduleFilenameFunc = function moduleFilenameFunc(_ref) {
          var name = _ref.name;

          if (finalThemes[name]) {
            return "".concat(finalThemes[name]);
          }

          return orgMiniCssExtractPlugin && orgMiniCssExtractPlugin.options.filename ? orgMiniCssExtractPlugin.options.filename : DEFAULT_CSS_OUTPUT_NAME;
        };

        if (orgMiniCssExtractPlugin) {
          orgMiniCssExtractPlugin.options.moduleFilename = moduleFilenameFunc;
        } else {
          var miniCssExtractPlugin = new MiniCssExtractPlugin({
            moduleFilename: moduleFilenameFunc
          });

          if (webpackNewVer) {
            miniCssExtractPlugin.apply(compiler);
          } else {
            compiler.apply(miniCssExtractPlugin);
          }
        }

        if (compiler.options.plugins && compiler.options.plugins.length > 0) {
          var excludeThemeChunks = themeList.map(function (theme) {
            return theme.key;
          });
          compiler.options.plugins.forEach(function (plugin) {
            if (plugin instanceof HtmlWebpackPlugin) {
              if (plugin.options.excludeChunks) {
                plugin.options.excludeChunks = [].concat(_toConsumableArray(excludeThemeChunks), _toConsumableArray(plugin.options.excludeChunks));
              } else {
                plugin.options.excludeChunks = excludeThemeChunks;
              }
            }
          });
        }
      };

      var onEmit = function onEmit(compilation, callback) {
        var stats = compilation.getStats().toJson();

        if (themeList && themeList.length > 0) {
          themeList.forEach(function (theme) {
            var outputByThemes = stats.assetsByChunkName[theme.key];

            if (outputByThemes) {
              var pattern = new RegExp("^".concat(theme.key, "(.*).(js|css)"));

              if (Array.isArray(outputByThemes)) {
                outputByThemes.forEach(function (fileName) {
                  if (pattern.test(fileName) && compilation.assets[fileName]) {
                    delete compilation.assets[fileName];
                  }
                });
              } else if (typeof outputByThemes === 'string') {
                if (pattern.test(outputByThemes) && compilation.assets[outputByThemes]) {
                  delete compilation.assets[outputByThemes];
                }
              }
            }
          });
        }

        if (callback && typeof callback === 'function') {
          callback();
        }
      };

      var onDone = function onDone() {
        fs.removeSync(TEMP_DIR);
      };

      if (webpackNewVer) {
        compiler.hooks.entryOption.tap(pluginInfo, onEntryOption);
        compiler.hooks.emit.tapAsync(pluginInfo, onEmit);

        if (clearTemp) {
          compiler.hooks.done.tap(pluginInfo, onDone);
        }
      } else {
        compiler.plugin('entry-option', onEntryOption);
        compiler.plugin('emit', onEmit);

        if (clearTemp) {
          compiler.plugin('done', onDone);
        }
      }
    }
  }, {
    key: "getThemeList",
    value: function getThemeList() {
      var _this$options2 = this.options,
          defaultStyleName = _this$options2.defaultStyleName,
          useStaticThemeName = _this$options2.useStaticThemeName;
      this.generateThemes();
      var ignoredFiles = [defaultStyleName || DEFAULT_STYLE_NAME];
      var themeList = [];
      var themeFileNames = fs.readdirSync(TEMP_THEMES_DIR).filter(function (file) {
        return ignoredFiles.indexOf(file) < 0;
      });
      themeFileNames.forEach(function (fileName) {
        var index = fileName.lastIndexOf('.');
        var key = index > -1 ? fileName.substr(0, index) : fileName;
        themeList.push({
          key: "theme-".concat(key),
          path: path.resolve(TEMP_THEMES_DIR, fileName),
          outputName: useStaticThemeName ? "theme-".concat(key, ".css") : "theme-".concat(key, "-").concat(randomNum(10000000, 99999999), ".css")
        });
      });
      return themeList;
    }
  }, {
    key: "generateThemes",
    value: function generateThemes() {
      var _this$options3 = this.options,
          srcDir = _this$options3.srcDir,
          themesDir = _this$options3.themesDir,
          defaultStyleName = _this$options3.defaultStyleName,
          importAfterVariables = _this$options3.importAfterVariables;
      fs.removeSync(TEMP_DIR);
      var orgFiles = fs.readdirSync(themesDir);

      if (!orgFiles || orgFiles.length === 0) {
        console.warn('No themes');
        return;
      }

      fs.ensureDirSync(TEMP_THEMES_DIR);
      var themesDependencies = [];
      var defaultStyle = defaultStyleName || DEFAULT_STYLE_NAME;
      var importPattern = new RegExp("@import (.+)".concat(defaultStyle, "(.+)"));
      collectFiles(srcDir, themesDependencies, function (file) {
        var fileContent = fs.readFileSync(file).toString();
        return importPattern.test(fileContent);
      });

      if (themesDependencies.length < 1) {
        orgFiles.forEach(function (file) {
          fs.copyFileSync(path.join(process.cwd(), themesDir, file), path.join(TEMP_THEMES_DIR, file));
        });
        return;
      }

      var importContent = '';
      themesDependencies.forEach(function (d) {
        return importContent += "@import '../../".concat(d, "';\n");
      });
      orgFiles.forEach(function (file) {
        var fileContent = fs.readFileSync(path.join(themesDir, file)).toString();
        fs.writeFileSync(path.join(TEMP_THEMES_DIR, file), importAfterVariables ? "".concat(fileContent, "\n").concat(importContent) : "".concat(importContent).concat(fileContent));
      });
    }
  }], [{
    key: "clearTemp",
    value: function clearTemp() {
      fs.removeSync(TEMP_DIR);
    }
  }]);

  return ThemesGeneratorPlugin;
}();

module.exports = ThemesGeneratorPlugin;